---
title: "Meningitis: Parietal Tissue"
subtitle: "Filtering and Normalization"
author: "Kennedi Todd"
date: "09/11/2023"
output:
  html_document:
    theme: cerulean
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: inline
---

# Setup
## Working directory
```{r setup}
knitr::opts_knit$set(root.dir = ".")
```

## Libraries
```{r libraries, message=FALSE, warning=FALSE}
library(caret)              # createDataPartition()
library(dplyr)              # left_join()
library(edgeR)              # DGEList()
library(limma)              # plotMDS()
library(ggrepel)            # geom_text_repel()
library(ggplot2)            # ggplot()
library(glmnet)             # cv.glmnet()
library(gplots)             # heatmap.2()
library(grDevices)          # colorRampPalette()
library(gridExtra)          # grid.arrange()
library(philentropy)        # JSD()
library(rtracklayer)        # import()
library(stringr)            # str_match()
```

## User defined variables
```{r set_variables}
tissue <- "parietal"
folder <- paste0(tissue,"_10CPM_in_11_samples")
groups <- c("control","meningitis")
group_colors <- c("orange","cornflowerblue")
ann <- "../../refs/chm13v2.0_RefSeq_Liftoff_v5.1.gff3"
```

## Save functions
These functions with help simultaneously save plots as a png, pdf, and tiff 
file.
```{r save_functions}
saveToPDF <- function(...) {
    d = dev.copy(pdf,...)
    dev.off(d)
}
```

# DGE object
## Read data
```{r read_data}
# read in counts data
counts <- read.delim(
  paste0("../../featureCounts/", tissue, "_sex_specific_counts_matrix.tsv"),
  header = TRUE,
  row.names = 1,
  sep = "\t")

# read metadata
meta <- read.delim("../../refs/metadata.tsv",
  header = TRUE,
  sep = "\t",
  row.names = NULL)
meta <- meta[meta$tissue == tissue,]

# match counts columns to meta rows
original.filenames <- colnames(counts)
new.filenames <- str_match(original.filenames, "(Mayo_[0-9]+_[MP]_S[0-9]+)_[XY]+")[,2]
colnames(counts) <- new.filenames
meta <- meta[meta$filename %in% colnames(counts),]
indices <- order(match(colnames(counts), meta$filename))
counts <- counts[,indices]
all.equal(colnames(counts), meta$filename)

# add reference genome info
meta$reference_genome <- original.filenames[indices]
meta$reference_genome <- str_match(meta$reference_genome, "Mayo_[0-9]+_[MP]_S[0-9]+_([XY]+)")[,2]

# rename counts columns
colnames(counts) <- meta$mayo_id

# factor meta
meta$sex <- factor(meta$sex, levels = c("female","male"))
meta$group <- factor(meta$group, levels = c("control","meningitis"))
meta$sex_group <- paste0(meta$sex,"_",meta$group)
#factor_columns <- c(14,15)
#dge$samples[factor_columns] <- lapply(dge$samples[factor_columns], factor)

# read in annotation file
if (file.exists("../../rObjects/annotation.rds")) {
  genes <- readRDS("../../rObjects/annotation.rds")
} else {
  genes <- rtracklayer::import(ann)
  genes <- as.data.frame(genes)
  genes <- genes[genes$type == "gene",]
  all.equal(rownames(counts), genes$ID) # check that rows match
  saveRDS(genes, "../../rObjects/annotation.rds")
}
genes <- genes[,c(1:7,10:16)]
all.equal(rownames(counts), genes$ID)

# remove all lncRNAs except for XIST
keep <- which(genes$gene_biotype == "protein_coding") # keep protein_coding
keep <- c(keep, which(genes$gene_biotype == "C_region")) # keep C_region
keep <- c(keep, which(genes$gene_biotype == "J_segment")) # keep J_segment
keep <- c(keep, which(genes$gene_biotype == "V_segment")) # keep V_segment
keep <- c(keep, which(genes$gene_name == "XIST")) # keep XIST
genes <- genes[keep,]
counts <- counts[keep,]


# read exonic length information
#exonic.length <- read.delim(
#  "../../backup_featureCounts/summed_exons.tsv",
#  header = TRUE,
#  sep = "\t"
#)

# add exonic length to genes
#all.equal(rownames(counts), genes$gene_id, exonic.length$gene_id)
#genes <- left_join(genes, exonic.length, by = "gene_id")
#remove(exonic.length)
```

## Create object
```{r DGE_object}
# create object
dge <- DGEList(counts = counts,
               genes = genes,
               samples = meta)

# cleanup 
remove(counts, meta, genes)
```

## Remove specific samples
- Mayo_24, a male control sample, is the only sample without brain weight or thal phase. Additionally, both the parietal and meninges tissue have the 2nd and 3rd lowest RIN out of all samples (parietal + meninges). 
- Mayo_08, a male control sample, has the lowest RIN of the meninges samples (after removing Mayo_24). On MDS plots this control sample does not group well with the others.
```{r}
#keep <- !colnames(dge) %in% c("Mayo_08","Mayo_18","Mayo_19","Mayo_24","Mayo_37")
keep <- dge$samples$RIN > 4
dge <- dge[,keep]
table(dge$samples$group)
table(dge$samples$sex_group)
```

## Remove MT genes
- Reference did not contain mitochondrial chromosome.
```{r remove_MT_genes, eval=FALSE, echo=FALSE}
#dim(dge)
#removeMT <- dge$genes$seqnames != "MT"  # true when NOT MT
#dge <- dge[removeMT,,keep.lib.sizes = FALSE]
#dim(dge)
```

## Protein coding genes
```{r keep_protein_coding}
#dim(dge)
#keep <- dge$genes$gene_biotype == "protein_coding"  # true when protein 
#dge <- dge[keep,,keep.lib.sizes = FALSE]
#dim(dge)
```

# QC: Raw
## CPM
Output table can be used with shiny app.
```{r cpm_raw}
# CPM, Counts Per Million
# normalize by sequencing depth
cpm <- cpm(dge)

path <- paste0("../../results/",folder,"/counts/CPM_before_filtering.tsv")
write.table(cpm, path, quote = FALSE, sep = "\t")

path <- paste0("../05_shiny/",folder,"/counts/CPM_before_filtering.tsv")
write.table(cpm, path, quote = FALSE, sep = "\t")
```

## JSD heatmap
This portion won't display in the R Markdown pdf; the margins are too large.
The pdf and png file can only be saved one at a time.
```{r jsd_heatmap, eval=FALSE}
# save
path <- paste0("../../results/",folder,"/prefiltering_QC/JSD_heatmap")
pdf(paste0(path,".pdf"), width = 8, height = 8, pointsize = 8)

# set heatmap colors and names
colors <- c("blue","skyblue","white") # set heatmap color scale
colors <- colorRampPalette(colors)(100) # make it a gradient
sample_group_color <- group_colors[dge$samples$group]
names <- dge$samples$mayo_id

# find JSD
data <- JSD(t(cpm(dge$counts)), est.prob = "empirical")
colnames(data) <- names
rownames(data) <- names
round.data <- round(data, digits = 2) # round 2 decimal places

# plot heatmap
heatmap <- heatmap.2(
  round.data,
  trace = "none",
  colCol = sample_group_color,
  colRow = sample_group_color,
  symm = TRUE,
  col = colors,
  cellnote = round.data,
  notecex = 0.6,
  dendrogram = "none",
  notecol = "black",
  key.title = "Color Key",
  srtCol = 65,
  margins = c(12,12),
  keysize = 0.2)

remove(heatmap,round.data,data)
```

## MDS
- MDS = multidimensional scaling \
- limma::plotMDS() will produce a PCoA or PCA plot \
- By default, gene.selection = "pairwise" \
- If gene.selection = "pairwise" and top is < nrow(x) then a PCoA plot is produced \
- Distances on the plot represent the leading log2 fold-changes \
- The leading log fold-change between a pair of samples is the root-mean-square average of the top largest log2 fold-changes between those two samples \
### Sex
```{r mds_prefiltering, warning=FALSE}
  # set colors and get data
data <- cpm(dge$counts, log = TRUE)
sex_color <- group_colors[dge$samples$sex]
names <- dge$samples$sex

# loop through dimensions and top genes
dims <- list(c(1,2),c(2,3),c(3,4),c(4,5))
topGenes <- c(100,500)

for (dim in dims) {
  
  for (numGenes in topGenes) {
      
    par(bg = 'white')
  
    # plot MDS
    plotMDS(
      data, 
      top = numGenes, 
      labels = names,
      cex = 1, 
      dim.plot = dim, 
      plot = TRUE, 
      col = sex_color
    )
    
    title(paste0("Raw: Top ", numGenes, ", Log2(CPM)"))
    
    legend(
      "topright",
      legend = unique(names),
      pch = 16,
      col = unique(sex_color),
      cex = 1
    )
    
    # save
    dimTitle <- as.character(dim)
    path <- paste0("../../results/",folder,"/prefiltering_QC/MDS_raw_", 
                   "top_", numGenes, "_",
                   "dim", as.character(dim)[1], "&", as.character(dim[2]), "_colored_by_sex")
    saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
  }
}

remove(data)
```

```{r}
#glMDSPlot(dge, labels = dge$samples$mayo_id, groups = dge$samples$group)
```

### Group
```{r}
# set colors and get data
data <- cpm(dge$counts, log = TRUE)
group_color <- group_colors[dge$samples$group]
names <- dge$samples$mayo_id

# loop through dimensions and top genes
dims <- list(c(1,2),c(2,3),c(3,4),c(4,5))
topGenes <- c(100,500)

for (dim in dims) {
  
  for (numGenes in topGenes) {
    
    par(bg = 'white')
    
    # plot MDS
    plotMDS(
      data, 
      top = numGenes, 
      labels = names,
      cex = 1, 
      dim.plot = dim, 
      plot = TRUE, 
      col = group_color
    )
    
    title(paste0("Raw: Top ", numGenes, ", Log2(CPM)"))
    
    legend(
      "topright",
      legend = unique(dge$samples$group),
      pch = 16,
      col = unique(group_color),
      cex = 1
    )
    
    # save
    dimTitle <- as.character(dim)
    path <- paste0("../../results/",folder,"/prefiltering_QC/MDS_raw_", 
                   "top_", numGenes, "_",
                   "dim", as.character(dim)[1], "&", as.character(dim[2]), "_colored_by_group")
    saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
  }
}

remove(data,dims)
```

Sum technical replicates. We have none.
```{r tech_reps}
# sum technical replicates
#dim(dge)
#dge.tech <- sumTechReps(dge, dge$samples$simplified_name)
#dim(dge.tech$counts)
#colnames(dge.tech$counts) <- dge.tech$samples$simplified_name
```

Plot MDS of summed technical replicates.
```{r mds_tech_reps}
# no tech reps in this data set
```

# Filtering and normalization
## Lowly expressed genes

The filterByExpr() function in the edgeR package determines which genes have a 
great enough count value to keep.  We will filter by group.  This means at least 
17 samples (17 is the smallest group sample size) must express a minimum count of 
10 (in cpm, default value).

```{r filter}
keep.expr <- filterByExpr(dge, group = dge$samples$group)
start <- dim(dge)[1]
dge.filtered <- dge[keep.expr, , keep.lib.sizes = FALSE]
end <- dim(dge.filtered)[1]
print(paste(start - end, "genes removed and", end, "genes leftover."))
```

## TMM
Convert observed library sizes into effective library sizes. To obtain effective
library sizes, the current library sizes are multiplied by a normalization factor
which we find using the trimmed mean of M values (TMM) method. The TMM method
trims observations from each tail of the distribution of log-rations (M-values). 
By default this method uses a sumTrim of 0.05 and a logratioTrim of 0.3.
```{r TMM_normalize}
# Normalize by trimmed mean of M-values
dge.filtered.norm <- calcNormFactors(dge.filtered, method = "TMM")

# Normalization factor summary
summary(dge.filtered.norm$samples$norm.factors)
```

# QC: After normalization
## Batch
```{r batch}
#df <- dge.filtered.norm$samples %>%
#  dplyr::count(group,lane) %>%
#  tidyr::spread(group, n)
#df
```

## Density plot
Density plots of log-intensity distribution of each library can be superposed 
on a single graph for a better comparison between libraries and for 
identification of libraries with weird distribution. 
```{r density_plots}
# set graphical parameter
par(mfrow = c(1,3))

# Normalize data for library size and expression intesntiy
log2cpm.raw <- cpm(dge, log = TRUE)
colnames(log2cpm.raw) <- dge$samples$mayo_id
log2cpm.filtered <- cpm(dge.filtered, log = TRUE)
colnames(log2cpm.filtered) <- dge.filtered$samples$mayo_id
log2cpm.norm <- cpm(dge.filtered.norm, log = TRUE)
colnames(log2cpm.norm) <- dge.filtered.norm$samples$mayo_id

# set colors
colors <- group_colors[dge$samples$group]
nsamples <- ncol(dge)

# First, plot the first column of the log2cpm.raw density
plot(density(log2cpm.raw[,1]), col = colors[1], lwd = 2, ylim = c(0,1), 
     las = 2, main = "A. Raw", xlab = expression('Log'[2]~CPM))

# For each sample plot the lcpm density
for (i in 2:nsamples){
  den <- density(log2cpm.raw[,i]) #subset each column
  lines(den$x, den$y, col = colors[i], lwd = 2) 
}

# Second, plot log2cpm.filtered
plot(density(log2cpm.filtered[,1]), col = colors[1], lwd = 2, ylim = c(0,0.25), 
     las = 2, main = "B. Filtered", xlab = expression('Log'[2]~CPM))
abline(v = cpm(3, log = TRUE), lty = 3)
for (i in 2:nsamples) {
  den <- density(log2cpm.filtered[,i])
  lines(den$x, den$y, col = colors[i], lwd = 2)
}

# Third, plot log2cpm.norm
plot(density(log2cpm.norm[,1]), col = colors[1], lwd = 2, ylim = c(0,0.25), 
     las = 2, main = "C. Normalized", xlab = expression('Log'[2]~CPM))
abline(v = cpm(3, log = TRUE), lty = 3)
for (i in 2:nsamples) {
  den <- density(log2cpm.norm[,i])
  lines(den$x, den$y, col = colors[i], lwd = 2)
}

# save
path <- paste0("../../results/",folder,"/postfiltering_QC/density_plots")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
remove(den)
```

## Boxplots
```{r boxplots}
# set parameters
par(mfrow = c(1,3))

# First look at dge.tech
boxplot(log2cpm.raw, 
        main="A. Raw", 
        xlab="", 
        ylab=expression('Counts per gene (Log'[2]~'CPM)'),
        axes=FALSE,
        col = colors
        )
axis(2) # 2 = left 
axis(1, # 1 = below 
     at = 1:nsamples, # points at which tick-marks should be drawn
     labels = colnames(log2cpm.raw),
     las = 2,
     cex.axis = 0.8 # size of axis
     )

# Second, look at dge.filtered
boxplot(log2cpm.filtered, 
        main="B. Filtered", 
        xlab="", 
        ylab=expression('Counts per gene (Log'[2]~'CPM)'),
        axes=FALSE,
        col = colors
        )
axis(2)
axis(1, at=1:nsamples,labels=colnames(log2cpm.filtered),las=2,cex.axis=0.8)

# Third, look at dge.norm
boxplot(log2cpm.norm, 
        main="C. Normalized", 
        xlab="", 
        ylab=expression('Counts per gene (Log'[2]~'CPM)'),
        axes=FALSE,
        col = colors)
axis(2)
axis(1,at=1:nsamples,labels=colnames(log2cpm.norm),las=2,cex.axis=0.8)

# save
path <- paste0("../../results/",folder,"/postfiltering_QC/boxplot")
saveToPDF(paste0(path, ".pdf"), width = 12, height = 4)
#remove(log2cpm.raw, log2cpm.norm, log2cpm.filtered)
```

## CPM
```{r cpm_fpkm_tpm}
# CPM, Counts Per Million
# normalize by sequencing depth
cpm <- cpm(dge.filtered.norm)

path <- paste0("../../results/",folder,"/counts/CPM_after_filtering.tsv")
write.table(cpm, path, quote = FALSE, sep = "\t")

path <- paste0("../05_shiny/",folder,"/counts/CPM_after_filtering.tsv")
write.table(cpm, path, quote = FALSE, sep = "\t")

remove(cpm)
```

## Top transcripts
```{r}
counts <- as.data.frame(dge.filtered.norm$counts)
df <- as.data.frame(rowSums(counts))
colnames(df) <- "rsum"
df$gene <- rownames(df)
df <- df[order(df$rsum, decreasing = TRUE),]
rownames(df) <- 1:nrow(df)
head(df, 20)

path <- paste0("../../results/",folder,
               "/counts/top_transcripts_after_filtering.tsv")
write.table(df, path, quote = FALSE, sep = "\t")
```

# Save
```{r save_final_object, eval=FALSE}
saveRDS(dge.filtered.norm, 
        paste0("../../rObjects/",folder,"_DGEList_filtered_normalized.rds"))
```

```{r session_info}
sessionInfo()
```
